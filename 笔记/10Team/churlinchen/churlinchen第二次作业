### 西点第二次作业
- 任务一（web安全）
- 任务二（密码学基础）
- 任务三（二进制逆向）
#### 任务一（web安全）：
- HTTP的认识
- HTTP的工作原理
- HTTP所属层次
- HTTP消息结构
- 客户端请求
- 服务器响应消息
- HTTP请求方法
- HTTP响应头消息
- HTTP状态码
- HTTP状态码分类
- HTTP内容类型
- Session ID
- cookies
- GET和POST的区别
- HTTP Proxies
- 作业
1. HTTP的认识
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网(WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。
HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
2. HTTP的工作原理
HTTP协议工作于客户端和服务端的架构上，客户端即浏览器通过URL向web服务器即服务端发送请求。
**web服务器的介绍**
IIS
IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。
Apache
Apache源于NCSAhttpd服务器，当NCSAWWW服务器项目停止后，那些使用NCSA WWW服务器的人们开始交换用于此服务器的补丁，这也是apache名称的由来（pache 补丁）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支开放的开发队伍、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。
Nginx
Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
**HTTP的三点注意事项**
HTTP是无连接：每次链接只处理一个请求
HTTP是媒体独立的：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。
HTTP是无状态的：无状态是指协议对于事务处理没有记忆能力。
**URL**:统一资源定位符,表示资源在互联网上的地址.
**URI**:是由某个协议方案表示的资源的定位标识符.
3. HTTP所属层次
HTTP协议是TCP/IP协议族中应用层的一种协议。
4. HTTP消息结构
HTTP是通过链接来进行信息的交换的，通过客户端发送请求，服务端接受请求并向客户端发送HTTP响应数据。一个客户端可以通过连接到服务器来发送一个或多个请求。HTTP使用统一的资源标识符来传输数据和建立连接。
5. 客户端请求消息
客户端请求消息的格式为：请求行、请求头部、空行和请求数据四部分组成。
6. 服务器响应消息
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
**状态行：**
当服务器响应时，其状态行的信息为HTTP的版本号，状态码，及解释状态码的简单说明。现将5类状态码详细列出：
① 客户方错误
100　 继续
101　 交换协议
② 成功
200 　OK
201 　已创建
202　 接收
203　 非认证信息
204　 无内容
205 　重置内容
206　 部分内容
③ 重定向
300 　多路选择
301　 永久转移
302　 暂时转移
303　 参见其它
304 　未修改（Not Modified）
305　 使用代理
④ 客户方错误
400　 错误请求（Bad Request）
401 　未认证
402 　需要付费
403　 禁止（Forbidden）             ---> 权限问题等
404　 未找到（Not Found）
405　 方法不允许
406　 不接受
407　 需要代理认证
408　 请求超时
409　 冲突
410 　失败
411 　需要长度
412　 条件失败
413 　请求实体太大
414 　请求URI太长
415 　不支持媒体类型
⑤ 服务器错误
500　 服务器内部错误
501　 未实现（Not Implemented）
502　 网关失败
504 　网关超时
505 HTTP版本不支持
7. HTTP请求方法
GET:指定信息，返回实体主体
HEAD:指定信息，只获取报头
POST:向指定资源提交数据处理请求，数据被包含在请求体中，该请求可能会引起新的资源的建立或已有资源的修改。
PUT:请求取代指定文档内容
DELETE:请求删除指定的页面
CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS:允许客户端查看服务器的性能。
TRACE:回显服务器的请求。
8. HTTP响应头信息
HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。
9. HTTP状态码
见“状态行”的阐述。
10. HTTP状态码分类
见“状态行”阐述。
11. HTTP content-type
用于定义网络文件的类型和网页的编码。
12. Session  ID
即请求间得状态追踪机制，
Session ID 通常通过以下方式来传递：
URL
隐藏的表单字段
HTTP报文头中的Cookie字段
13. Cookies
发起一个回话是，服务器会发送一个Set-cookies响应头
结构为：
NAME=VALUE键值对+Domain+Path+Expires+Secure
14. GET和POST的区别
GET是用来获取资源，POST使用来处理资源。
15. HTTP proxies
所有的HTTP请求，都是先发到代理服务器，然后由代理服务器重新包装后，再发给目标(实际)服务器，响应也是如此，代理服务器先接收来自目标(实际)服务器的响应，然后包装后发给客户机。


#### 任务二（密码学基础）：
- 熟悉各进制（包括二、八、十和十六进制）
- 各进制之间的转换
- 逻辑运算
**二进制**：由0和1构成，逢二进一。
**八进制**：有0-7八个数字，逢八进一，二进制的三位可构成八进制的一位。
**十进制**：有0-9十个数字，逢十进一。
**十六进制**：有0-9和ABCDEF十六个数字构成，二进制的四位可够成十六进制的一位。
 
 **进制之间的转换**
 1. 各进制（二、八、十六）转成十进制
 *二进制转十进制*：二进制从低位算起，第0位的权值是2得0次方，第二位的权值是2的1次方，第三位的权值是2的2次方，依次递增下去，把结果都加起来就是十进制的值。
 *八进制转为十进制*：类似的，八进制的第一位的权值是8的0次方，第二位是8的1次方，依次递增下去，把结果都加起来就是十进制的值。
 *十六进制转为十进制*：从低位算起，十六进制的第一位为16的0次方，第二位为十六的1次方，依次递增，把结果都加起来就是十进制的值了。
 2. **十进制转为各进制（二、八、十六）**
 **十进制转为二进制**：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。
 **十进制转为八进制**：类似的，除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。
 **十进制转十六进制**：除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。
 3. 二进制转八和十六进制
**二进制转成八进制**： 取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。 
**二进制转十六进制**：类似的，取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。
4. 八进制和十六进制转为二进制法
*八进制转为二进制法*：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。
*十六进制转二进制法*：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。
5. 八进制和十六进制之间的转换
都转换为二进制然后再转换为彼此。

**与或非异的逻辑运算**
 逻辑非：即求反，0变1,1变0；
 逻辑或：真||假=真（1+0=1）
 假||真=真（0+1=1）
 假||假=假（0+0=0）
 真||真=真（1+1=1）
 逻辑与：1*1=1
 1*0=0
 0*1=0
 0*0=0
 逻辑异运算：
 1+1=2进位=0
 1+0=1
 0+1=1
 0+0=0
### 小测验
 1.想想看，时钟用的是什么进制呢？ 
2.将二进制数1111000010.01101分别转换为八进制、十进制和十六进制数。 
3.将十进制数137.5分别转换成二进制、八进制。
解：1.秒向分进位用的是六十进制，分向时进位用的是六十进制。
2.
转换为八进制：1111000010.01101可拆分成001  111  000  010.011  010每三位看成八进制的一位
则八进制数为：1702.32
转换为十进制：先算整数位
1111000010=0*2^0+1*2^1+1*2^6+1*2^7+1*2^8+1*2^9=962
再算小数位：
0.01101=2^（-2）+2^（-3）+2^（-5）=0.40625
即十进制数为962.40625
转换为十六进制：1111000010.01101可拆分成0011  1100  0010.0110  1000每四位看成一位则十六进制数为：3C2.68
3.
转换为二进制：整数部分：137/2=68余1
68/2=34余0
34/2=17余0
17/2=8余1
8/2=4余0
4/2=2余0
2/2=1余0
1/2余1
小数部分：0.5/2=0.2余0.1
则二进制数位10001001.1
转换为八进制：整数部分：137/8=17余1
17/8=2余1
2/8余2
小数部分：0.5/8余0.5
则八进制数位：211.5

任务三：
### 使用寄存器
#### 汇编语言中的整数常量表示
十进制整数表示为[十进制整数]d orD，为汇编器默认的数制。
十六进制数可表示为0[十六进制数]h或0[十六进制数]H，开头的0可省略。调试器默认十六进制表示整数。
八进制数可表示为[八进制数]q获Q。
#### 简单指令
寄存器与立即数的表示：
reg32，32-bit寄存器，如EAX、EBX等。
reg16，16-bit寄存器，如AX，BX等。
reg8？，8-bit寄存器，如AL，BH等。
imm32，32-bit立即数，可以理解为常数。
imm16，16-bit立即数。
imm8？ 8-bit立即数。

**MOV指令**
功能：可将寄存器中的内容取出后送到另一寄存器中，也可直接把立即数发送到寄存器中。
格式：例：mov  eax,ebx  ;把ebx中的内容取出送入eax中；
mov eax,010h          ;将010h载入eax中

**xchg指令**
功能：把寄存器中之间的值进行调换。
格式：xchg  ebx,ecx,表示ebx和ecx的数值被调换。

**递增（减）指令  inc （ dec）**
功能：递增、递减指令，是对无符号或有符号整数进行自动增加或减小一个单位的操作，数据长度可以是字节、字或双字。
格式：字节递增指令：INCB OUT
执行结果：OUT +1=OUT
字节递减指令：DECB OUT
 执行结果：OUT -1=OLT
 字节不带符号运算，而字和双字都是带符号运算

**add指令**
功能：将寄存器的数值与另一寄存器或立即数的值相加，并存回此寄存器。
格式：add reg32(16,8),reg32(16,8)/imm(8,16,32)
SUB为减法指令，格式和add相同

**lea指令**
功能：目标地址传送指令：将一个近地址指针写入到指定的寄存器。
格式：lea  ax,buf    ;将存储器buf所指的地址传送给ax。

**rep,stos指令**
功能：rep指令的作用是重复上面的指令，ecx的值是重复次数。STOS指令是将EAX中的值拷贝到一个目的地址中。
格式：rep stos dword ptr es:[edi]
REP指令可以是任何字符串指令（CMPS、LODS、MOVS、SCAS、STOS）的前缀。 REP能够引发其后的字符串指令被重复，只要ECX的值不为0，重复就会继续。每一次字符串指令执行后，ECX的值都会减小。
STOS(store into string)意思是把EAX的内容拷贝到一个目的地址。 用法：stos dst，dst是一个目的地址，例如stos dword ptr es:[edi]。dword ptr（强制转换成dword格式）前缀是告诉stos，一次拷贝双字（4个字节）到目的地址。

**逻辑运算**
逻辑运算指令是另一组重要的指令，它包括：逻辑与(AND)、逻辑或(OR)、逻辑非(NOT)和异或指令(XOR)，逻辑运算指令也是经常使用的指令。

1、逻辑与操作指令AND(Logical AND Instruction)

指令的格式：AND　Reg/Mem, Reg/Mem/Imm
受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)
指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“与操作”，操作结果存入目标操作数中。

例： 已知(BH)=67H，要求把其的第0、1和5位置为0。


解：可以构造一个立即数，其第0、1和5位的值为0，其它位的值为1，该立即数即为：0DCH或11011100B，然后用指令"AND BH, 0DCH"来实现此功能。

2、逻辑或操作指令OR(Logical OR Instruction)

指令的格式：OR　Reg/Mem, Reg/Mem/Imm
受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)
指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑"或操作"，操作结果存入目标操作数中。

例5.7 已知(BL)=46H，要求把其的第1、3、4和6位置为1。


解：构造一个立即数，使其第1、3、4和6位的值为1，其它位的值为0，该立即数即为：5AH或01011010B，然后用指令"OR BL, 5AH"来实现此功能。

3、逻辑非操作指令NOT(Logical NOT Instruction)

指令的格式：NOT　Reg/Mem
其功能是把操作数中的每位变反，即：1←0，0←1。指令的执行不影响任何标志位。

例5.8 已知(AL)=46H，执行指令“NOT　AL”后，AL的值是什么？

解：执行该指令后，(AL)=0B9H。其计算过程如下所示。 

 

4、逻辑异或操作指令XOR(Exclusive OR Instruction)

指令的格式：XOR　Reg/Mem, Reg/Mem/Imm
受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)
指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑"异或操作"，操作结果存入目标操作数中。

例5.9 已知(AH)=46H，要求把其的第0、2、5和7位的二进制值变反。


解：构造一个立即数，使其第0、2、5和7位的值为1，其它位的值为0，该立即数即为：0A5H或10100101B，然后再用指令"XOR  AH, 0A5H"来实现此功能。

**cmp指令**
cmp（compare）指令比较两个操作数的大小，进行的运算是第一个操作数减去第二个操作数，但结果不会影响两个操作数的值，只会影响flag的CF、ZF、OF、AF、PF。 对各个flag的影响如下：

若执行指令后
ZF=1 这个简单，则说明两个数相等，因为zero为1说明结果为0
当无符号时：
若
CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1<oprd2
CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1>oprd2
当有符号时：
若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1>oprd2
若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1<oprd2
若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1<oprd2
若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1>oprd2
最后两个可以作出这种判断的原因是，溢出的本质问题：
两数同为正，相加，值为负，则说明溢出
两数同为负，相加，值为正，则说明溢出
故有，正正得负则溢出，负负得正则溢出

**跳转指令**
跳转指令分三类：

1. 无条件跳转：JMP
2. 根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）
3. 根据EFLAGS寄存器的标志位跳转，列表如下：
JE   ;等于则跳转
	JNE  ;不等于则跳转

	JZ   ;为 0 则跳转
	JNZ  ;不为 0 则跳转

	JS   ;为负则跳转
	JNS  ;不为负则跳转

	JC   ;进位则跳转
	JNC  ;不进位则跳转

	JO   ;溢出则跳转
	JNO  ;不溢出则跳转

	JA   ;无符号大于则跳转
	JNA  ;无符号不大于则跳转
	JAE  ;无符号大于等于则跳转
	JNAE ;无符号不大于等于则跳转

	JG   ;有符号大于则跳转
	JNG  ;有符号不大于则跳转
	JGE  ;有符号大于等于则跳转
	JNGE ;有符号不大于等于则跳转

	JB   ;无符号小于则跳转
	JNB  ;无符号不小于则跳转
	JBE  ;无符号小于等于则跳转
	JNBE ;无符号不小于等于则跳转

	JL   ;有符号小于则跳转
	JNL  ;有符号不小于则跳转
	JLE  ;有符号小于等于则跳转
	JNLE ;有符号不小于等于则跳转

	JP   ;奇偶位置位则跳转
	JNP  ;奇偶位清除则跳转
	JPE  ;奇偶位相等则跳转
	JPO  ;奇偶位不等则跳转
**Intel 80386**
80386有三种工作模式：真实模式、保护模式、虚拟86模式。真实模式为DOS系统的常用模式，直接内存访问空间被限制在1M位元组；保护模式下80386-DX可以直接访问4G位元组的内存，并具有异常处理机制；虚拟86模式可以同时模拟多个8086处理器来加强多工处理能力。
Intel 80386只有在进入保护模式后，才能充分发挥其强大的功能，提供更好的保护机制和更大的寻址空间，否则仅仅是一个快速的8086而已。没有一定的保护机 制，任何一个应用软件都可以任意访问所有的计算机资源。

模式的区别：实模式：每个指针都可以指向内存，即可直接访问内存，若修改用户程序或系统程序，其后果非常严重。
保护模式：为克服实模式下的内存管理的弊端，处理机开发商推出了保护模式。即物理地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。

**64位奔腾4处理器工作模式**

基本模式： 保护模式：纯32位保护执行环境。 实模式：纯16位无保护执行环境。 系统管理模式：当SMI引脚为有效进入系统管理模式，首先保存当前的CPU上下文。它有独立的地址空间，用来执行电源管理或系统安全方面的指令。
扩展模式： IA-32e模式，64位操作系统运行在该模式。 该模式有两种子模式: 1）兼容模式：该模式下，64位操作系统运行在32位兼容环境，能正常运行16，32位应用程序就像基本的保护模式一样，访问32位地址空间，但不能运行纯16位实模式程序（就是不能运行虚拟86模式程序了）。 2）64位模式：在该模式下，处理器完全执行64位指令，使用64位地址空间和64操作数，运行16，32位程序必须切换到兼容模式。 IA-32e子模式的切换完全基于代码段寄存器。这样一来，运行在IA-32e模式中（64位）的OS完全可以无缝的运行所有16，32，64为应用程序，通过设置32位后的CS。
